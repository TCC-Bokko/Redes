//Antonio Cardona Costa
//conectividad
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

//io
#include <stdio.h>
//error
#include <errno.h>
#include <string.h>
//setuid
#include <unistd.h>
#include <sys/types.h>
//time
#include <time.h>
#include <sys/time.h>
//Para que funcione lo del time, al llamar usar: realtime*

/*
//funciones de tiempo
time_t time(time_t *t);
int clock_gettime(clockid_t id, struct timespec *res);
int clock_settime(clockid_t id, struct timespec *tp);
size_t strftime (char* s, size_t max, const char* format, const struct tm *tm);
//Funciones de sleep
int nanosleep (const struct timespec *req, struct timespec* rem);
int usleep (useconds_t usec);
unsigned int sleep (unsigned int seconds);

//Variables
struct timespec {
	time_t tv_sec;
	long tv_nsec;
}
const char *sys_errlist[];
int sys_nerr;
int errno;
*/


//Cuerpos de funciones

int main(int argc, char **argv) {
   /* Comprobar la ocurrencia de error y notificarlo con la llamada perror(3) */

    int result;
    int errsv;
    //setuid(0);
    result = setuid(2); 

    if (result != 0) {
	//Ejercicio 1
	errsv = errno;
	perror("(perror) Error: ");
	//Ejercicio 2
	printf("(printf) Error: %i", errsv);
	strerror(errsv);
    }

    //Ejercicio 3
    
    time_t time(time_t* t); //trabajando en ello
    char* c_time_string;
    if (t != NULL){
  	printf("Current time is %s", c_time_string);
    }

    /////////////////
    // PRACTICA 2.2
    /////////////////
    /*

    //Parte conectividad
    while(true){
	char buf[256];


    }

    //Mensaje UDP

    //Mensaje TCP
    struct addrinfo hints;
    struct addrinfo *res;

    memset((void*) &hints, '\0', sizeof(struct addrinfo));
    hints.ai_family = AF_INET; // ipV4 = AF_INET, ipV6 = AF_INET6, ambos = AF_UNESPEC 
    hints.ai_socktype = SOCK_STREAM; // tcp = SOCK_STREAM , utp = SOCK_DGRAM

    int rc = getaddrinfo(argv[1], argv[2], &hints, &res)M

    if (rc !=0) {
	std::cout << "error getaddrinfo(): " << gai_strerror(rc) << std::endl;
	return -1;
    }
    
    int sd = socket(res->ai_family, res->ai_socktype, 0);

    bind(sd, res->ai_addr, res->ai_addrlen);

    listen(sd, 15);

    freeaddrinfo(res);

    while(true){
	char buf(256);
	//Conexion
	struct sockaddr src_addr;
	socklen_t addrlen;

	char host[NI_MAXHOST];
	char serv[NI_MAXSERV];

	ssize_t s = recvfrom(sd, buf, 255, 0, &src_addr, &addrlen);
	
	getnameinfo(src_addr, addrlen, host, NI_MAXHOST, serv, NI_MAXSERV, NI_NUMERICHOST | NI_NUMERICSERV);
	
	//Mensajes tcp/udp
	std::cout << "Conexion: " << host << ":" << serv << "\n";
	ssize_t s = recv(sd_src, buf, 255, 0);
 	std::cout << "Mensaje: " << buf << std::endl;
	send(sd, buf, s, 0);
    }
    
    return 0;
    */

    return 1;
}


